<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="45">
  <CheatEntries>
    <CheatEntry>
      <ID>4</ID>
      <Description>"Poll For Memory Addresses"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$lua}
-- Helper functions
local function tableLength(table)
  local count = 0
  for _ in pairs(table) do count = count + 1 end
  return count
end
local function hasValue (table, val)
  for index, value in ipairs(table) do
      if value == val then
          return true
      end
  end
  return false
end

KOAddr = "RivalsofAether.exe+3BCAB0F"
PercentageAddr = "RivalsofAether.exe+1FE8EB0"
StandingsAddr = "RivalsofAether.exe+3BCA919"
CharactersAddr = "RivalsofAether.exe+3EE042B"

[ENABLE]

-- Find the KO counter addresses
-- ref: mov [eax],00000000 - mov [esi+24],0000011C - test [esi+44],00FFFFFF
-- print("Finding KO Addresses")
foundKOlist = {}
debug_setBreakpoint(KOAddr,function()
  -- print(string.format("%X",EAX))
  if not foundKOlist[EAX] then
    local index = string.sub(string.format("%X",EAX), -2, -2)
    local name = "P"..index.."StocksLost"
    -- print(name)
    if hasValue({'1', '2', '3', '4'}, index) then
      local valuesMemaddr = getAddressList().getMemoryRecordByDescription("Values")
      local memaddr = getAddressList().createMemoryRecord()
      memaddr.Description = name
      memaddr.Address = EAX
      memaddr.VarType = vtDouble
      memaddr.appendToEntry(valuesMemaddr)
      foundKOlist[EAX]=true
    end
    if tableLength(foundKOlist) == 4 then
      -- print("All KO addresses found")
      debug_removeBreakpoint(KOAddr)
    end
  end
end)

-- Find the percentage addresses
-- ref: movsd xmm0,[eax] - movsd xmm1,[eax+08] - mov ecx,00FFFFFF
-- print("Finding percentage addresses")
foundPercentagelist = {}
debug_setBreakpoint(PercentageAddr,function()
  -- print(string.format("%X",EAX))
  if not foundPercentagelist[EAX] then
    local index = string.sub(string.format("%X",EAX), -2, -2)
    local name = "P"..index.."Percentage"
    if hasValue({'1', '2', '3', '4'}, index) then
      local valuesMemaddr = getAddressList().getMemoryRecordByDescription("Values")
      local memaddr = getAddressList().createMemoryRecord()
      memaddr.Description = name
      memaddr.Address = EAX
      memaddr.VarType = vtDouble
      memaddr.appendToEntry(valuesMemaddr)
      foundPercentagelist[EAX]=true
    end
    if tableLength(foundPercentagelist) == 4 then
      -- print("All percentage addresses found")
      debug_removeBreakpoint(PercentageAddr)
    end
  end
end)

-- Find the standing addresses
-- ref: mov [eax],00000000 - mov [esi+24],00000118 - test [esi+44],00FFFFFF
-- print("Finding standing addresses")
foundStandinglist = {}
debug_setBreakpoint(StandingsAddr,function()
  -- print(string.format("%X",EAX))
  if not foundStandinglist[EAX] then
    local index = string.sub(string.format("%X",EAX), -2, -2)
    local name = "P"..index.."Standing"
    if hasValue({'1', '2', '3', '4'}, index) then
      local valuesMemaddr = getAddressList().getMemoryRecordByDescription("Values")
      local memaddr = getAddressList().createMemoryRecord()
      memaddr.Description = name
      memaddr.Address = EAX
      memaddr.VarType = vtDouble
      memaddr.appendToEntry(valuesMemaddr)
      foundStandinglist[EAX]=true
    end
    if tableLength(foundStandinglist) == 4 then
      -- print("All standing addresses found")
      debug_removeBreakpoint(StandingsAddr)
    end
  end
end)

-- Find the character ID addresses
-- ref: movsd xmm0,[eax] - movsd xmm1,[eax+08] - mov eax,00FFFFFF
-- print("Finding character addresses")
foundCharacterIDlist = {}
debug_setBreakpoint(CharactersAddr,function()
  -- print(string.format("%X",EAX))
  if not foundCharacterIDlist[EAX] then
    local index = string.sub(string.format("%X",EAX), -2, -2)
    local name = "P"..index.."Character"
    if hasValue({'1', '2', '3', '4'}, index) then
      local valuesMemaddr = getAddressList().getMemoryRecordByDescription("Values")
      local memaddr = getAddressList().createMemoryRecord()
      memaddr.Description = name
      memaddr.Address = EAX
      memaddr.VarType = vtDouble
      memaddr.appendToEntry(valuesMemaddr)
      foundCharacterIDlist[EAX]=true
    end
    if tableLength(foundCharacterIDlist) == 4 then
      -- print("All characters found")
      debug_removeBreakpoint(CharactersAddr)
    end
  end
end)

-- Find the "is not in match" address
-- print("Finding 'is not in match' address")
-- debug_setBreakpoint("RivalsofAether.exe+93FC98",function()
  -- print(string.format("%X",EAX))
  -- local name = "IsInMatch"
  -- local valuesMemaddr = getAddressList().getMemoryRecordByDescription("Values")
  -- local memaddr = getAddressList().createMemoryRecord()
  -- memaddr.Description = name
  -- memaddr.Address = EAX
  -- memaddr.VarType = vtDouble
  -- memaddr.appendToEntry(valuesMemaddr)
  -- print("'Is in match' address found")
  --debug_removeBreakpoint("RivalsofAether.exe+93FC98")
-- end)

[DISABLE]
-- print("Disabling breakpoints")
debug_removeBreakpoint(KOAddr)
debug_removeBreakpoint(PercentageAddr)
debug_removeBreakpoint(StandingsAddr)
debug_removeBreakpoint(CharactersAddr)
--debug_removeBreakpoint("RivalsofAether.exe+93FC98")
local valuesMemaddr = getAddressList().getMemoryRecordByDescription("Values")
if valuesMemaddr ~= nil and valuesMemaddr.Count &gt; 0 then
  while valuesMemaddr.Count &gt; 0 do
    valuesMemaddr.Child[0]:Delete()
  end
end
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>6</ID>
      <Description>"Poll Changes &amp; Send to Server"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$lua}
-- Edit these variables to your liking
URL = "http://localhost/results" -- URL where the data gets sent to
Header = "access-token: xxxx"
PollRate = 2000 -- How much time in miliseconds will this script poll for changes
DiffHandler = "standing" -- Set to "standing" to only send data to server when standings are set, set to anything else to send for any other changes.

-- Rivals of Aether memory addresses
MemoryAddresses = {
  P1StocksLost = 0,
  P1Percentage = 0,
  P1Standing = 0,
  P1Character = 0,
  P2StocksLost = 0,
  P2Percentage = 0,
  P2Standing = 0,
  P2Character = 0,
  P3StocksLost = 0,
  P3Percentage = 0,
  P3Standing = 0,
  P3Character = 0,
  P4StocksLost = 0,
  P4Percentage = 0,
  P4Standing = 0,
  P4Character = 0
}
-- Addresses from previous poll. Used to determine if changes were made.
PreviousAddresses = {
  P1StocksLost = 0,
  P1Percentage = 0,
  P1Standing = 0,
  P1Character = 0,
  P2StocksLost = 0,
  P2Percentage = 0,
  P2Standing = 0,
  P2Character = 0,
  P3StocksLost = 0,
  P3Percentage = 0,
  P3Standing = 0,
  P3Character = 0,
  P4StocksLost = 0,
  P4Percentage = 0,
  P4Standing = 0,
  P4Character = 0
}

-- Force lua engine to not show when there are errors
getLuaEngine().cbShowOnPrint.Checked=false
getLuaEngine().hide()

if syntaxcheck then return end
if not scriptTimers then scriptTimers = {} end

-- Helper function to copy one table's data to another
local function copyTable(src)
  local dest = {}
  for key, value in pairs(src) do
    if type(value) == "table" then
      dest[key] = copyTable(value)
    else
      dest[key] = value
    end
  end
  return dest
end

local urlencodeTable = function(tbl)
    local function urlencode(str)
        if str then
            str = string.gsub(str, "([^%w])", function(c)
                return string.format("%%%02X", string.byte(c))
            end)
        end
        return str
    end

    local encoded_parts = {}
    for k, v in pairs(tbl) do
        local key = urlencode(tostring(k))
        local value = urlencode(tostring(v))
        table.insert(encoded_parts, key .. "=" .. value)
    end
    return table.concat(encoded_parts, "&amp;")
end

-- Function to send data to your HTTP server
local sendToServer = function(data)
  local internet = getInternet()
  if Header then
    internet.Header = Header
  end
  local result = internet.postURL(URL, data)
  PreviousAddresses = copyTable(MemoryAddresses)
end

-- Gets the values from CheatEngine
local function getValues()
  addressGroup = getAddressList().getMemoryRecordByDescription("Values")
  for i=0, addressGroup.Count do
    local child = addressGroup.Child[i]
    if (child and child.Value) then
      local value = math.floor(child.Value) -- Read the value from the memory address. Function exists in CE.
      MemoryAddresses[child.Description] = value -- Add the value to the data table
    end
  end
end

-- Main loop
local function onTimerTick()
  getValues()
  if (DiffHandler == "standing") then
    if (MemoryAddresses["P1Standing"] ~= PreviousAddresses["P1Standing"] or MemoryAddresses["P2Standing"] ~= PreviousAddresses["P2Standing"] or MemoryAddresses["P3Standing"] ~= PreviousAddresses["P3Standing"] or MemoryAddresses["P4Standing"] ~= PreviousAddresses["P4Standing"]) then
      sendToServer(urlencodeTable(MemoryAddresses))
    end
  else
    for index, value in pairs(MemoryAddresses) do
      if value ~= PreviousAddresses[index] then
        sendToServer(MemoryAddresses)
        break
      end
    end
  end
end


[ENABLE]

local id = memrec.ID
local t = scriptTimers[id]

if t then
  t.Enabled = true
else
  scriptTimers[id] = createTimer()
  t = scriptTimers[id]
  t.Interval = PollRate
  t.OnTimer = onTimerTick
end

[DISABLE]

local t = scriptTimers[memrec.ID]
if t then
  t.Enabled = false
end

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>5</ID>
      <Description>"Values"</Description>
      <GroupHeader>1</GroupHeader>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>gml_CScriptList</Name>
      <Address>67E6E1C</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>gml_ObjectArray</Name>
      <Address>67E6E04</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>gml_GlobalVariables</Name>
      <Address>67D6268</Address>
    </SymbolEntry>
    <SymbolEntry>
      <Name>gml_StringsList</Name>
      <Address>674F79C</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
  <DisassemblerComments>
    <DisassemblerComment>
      <Address>80A1592D</Address>
      <Header>CHECK OWNED
</Header>
    </DisassemblerComment>
  </DisassemblerComments>
</CheatTable>
